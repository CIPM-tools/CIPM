package cipm.consistency.fitests.similarity.jamopp.unittests.complextests;

import java.util.ArrayList;
import java.util.stream.Stream;

import org.emftext.language.java.statements.Statement;
import org.emftext.language.java.statements.StatementListContainer;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import cipm.consistency.fitests.similarity.jamopp.AbstractJaMoPPSimilarityTest;
import cipm.consistency.fitests.similarity.jamopp.unittests.IStatementPositionTest;
import cipm.consistency.fitests.similarity.jamopp.unittests.UsesStatements;
import cipm.consistency.initialisers.jamopp.statements.IStatementInitialiser;
import cipm.consistency.initialisers.jamopp.statements.IStatementListContainerInitialiser;

/**
 * Tests whether similarity checking works as intended for {@link Statement}
 * instances, which are contained in {@link StatementListContainer} instances.
 * Since testing that requires setup effort that goes beyond simplistic tests,
 * it is done here. <br>
 * <br>
 * Tests are parameterised over all possible combinations of
 * {@link StatementListContainer} and {@link Statement} implementors.
 * 
 * @author Alp Torac Genc
 */
public class StatementPositionTest extends AbstractJaMoPPSimilarityTest
		implements UsesStatements, IStatementPositionTest {
	/**
	 * @return Parameters for the test methods in this test class. Refer to their
	 *         documentation for more information.
	 */
	private static Stream<Arguments> genTestParams() {
		var res = new ArrayList<Arguments>();

		for (var stInit : getEachInitialiserOnceFor(IStatementInitialiser.class)) {
			for (var slcInit : getEachInitialiserOnceFor(IStatementListContainerInitialiser.class)) {
				res.add(Arguments.of(stInit, slcInit,
						String.format("%s inside %s", stInit.getInstanceClassOfInitialiser().getSimpleName(),
								slcInit.getInstanceClassOfInitialiser().getSimpleName())));
			}
		}

		return res.stream();
	}

	/**
	 * Tests if {@link Statement} instances contained by their respective
	 * {@link StatementListContainer} instance are similar, provided they are
	 * contained in the same order.
	 * 
	 * @param displayName   The display name of the test
	 * @param containerInit The initialiser that will be used to instantiate the
	 *                      statement list container
	 * @param containeeInit The initialiser that will be used to instantiate the
	 *                      statement that will be added to the constructed
	 *                      container
	 */
	@ParameterizedTest(name = "Statement in middle: {2}")
	@MethodSource("genTestParams")
	public void test_SamePredecessor_SameSuccessor(IStatementInitialiser containeeInit,
			IStatementListContainerInitialiser containerInit, String displayName) {
		var slc1 = containerInit.instantiate();
		Assertions.assertTrue(containerInit.initialise(slc1));
		var slc2 = containerInit.instantiate();
		Assertions.assertTrue(containerInit.initialise(slc2));

		// Use 3 statements to make sure that there is always a predecessor and a
		// successor for the statement generated by containeeInit

		var pred1 = this.createMinimalLVS("lv1");
		var st1 = containeeInit.instantiate();
		var succ1 = this.createMinimalLVS("lv2");

		// Make sure that the surrounding statements are not similar
		this.assertSimilarityResult(pred1, succ1, false);
		var sts1 = new Statement[] { pred1, st1, succ1 };

		var pred2 = this.cloneEObj(pred1);
		var st2 = this.cloneEObj(st1);
		var succ2 = this.cloneEObj(succ1);

		// Make sure that clones of surrounding statements are not similar
		this.assertSimilarityResult(pred2, succ2, false);
		var sts2 = new Statement[] { pred2, st2, succ2 };

		Assertions.assertTrue(containerInit.addStatements(slc1, sts1));
		Assertions.assertTrue(containerInit.addStatements(slc2, sts2));

		this.assertSimilarityResult(pred1, pred2, true);
		this.assertSimilarityResult(pred1, st2, false);
		this.assertSimilarityResult(pred1, succ2, false);

		this.assertSimilarityResult(st1, pred2, false);
		this.assertSimilarityResult(st1, st2, true);
		this.assertSimilarityResult(st1, succ2, false);

		this.assertSimilarityResult(succ1, pred2, false);
		this.assertSimilarityResult(succ1, st2, false);
		this.assertSimilarityResult(succ1, succ2, true);
	}

	/**
	 * Tests whether {@link Statement} instances contained by their respective
	 * {@link StatementListContainer} instance are not similar, if they have
	 * different predecessors and same successors.
	 * 
	 * @param displayName   The display name of the test
	 * @param containerInit The initialiser that will be used to instantiate the
	 *                      statement list container
	 * @param containeeInit The initialiser that will be used to instantiate the
	 *                      statement that will be added to the constructed
	 *                      container
	 */
	@ParameterizedTest(name = "Statement in middle: {2}")
	@MethodSource("genTestParams")
	public void test_DifferentPredecessor_SameSuccessor(IStatementInitialiser containeeInit,
			IStatementListContainerInitialiser containerInit, String displayName) {
		var slc1 = containerInit.instantiate();
		Assertions.assertTrue(containerInit.initialise(slc1));
		var slc2 = containerInit.instantiate();
		Assertions.assertTrue(containerInit.initialise(slc2));

		// Use 3 statements to make sure that there is always a predecessor and a
		// successor for the statement generated by containeeInit

		var pred1 = this.createMinimalLVS("lv1");
		var st1 = containeeInit.instantiate();
		var succ1 = this.createMinimalLVS("lv2");

		// Make sure that the surrounding statements are not similar
		this.assertSimilarityResult(pred1, succ1, false);
		var sts1 = new Statement[] { pred1, st1, succ1 };

		// Use a new LVS to make sure pred2 and succ2 are not similar
		var pred2 = this.createMinimalLVS("lv3");
		var st2 = this.cloneEObj(st1);
		var succ2 = this.cloneEObj(succ1);

		// Make sure that clones of surrounding statements are not similar
		this.assertSimilarityResult(pred2, succ2, false);
		// Make sure that predecessors are not similar
		this.assertSimilarityResult(pred2, pred1, false);

		var sts2 = new Statement[] { pred2, st2, succ2 };

		Assertions.assertTrue(containerInit.addStatements(slc1, sts1));
		Assertions.assertTrue(containerInit.addStatements(slc2, sts2));

		this.assertSimilarityResult(pred1, pred2, false);
		this.assertSimilarityResult(pred1, st2, false);
		this.assertSimilarityResult(pred1, succ2, false);

		this.assertSimilarityResult(st1, pred2, false);
		this.assertSimilarityResult(st1, st2, true);
		this.assertSimilarityResult(st1, succ2, false);

		this.assertSimilarityResult(succ1, pred2, false);
		this.assertSimilarityResult(succ1, st2, false);
		this.assertSimilarityResult(succ1, succ2, true);
	}

	/**
	 * Tests whether {@link Statement} instances contained by their respective
	 * {@link StatementListContainer} instance are not similar, if they have same
	 * predecessors and different successors.
	 * 
	 * @param displayName   The display name of the test
	 * @param containerInit The initialiser that will be used to instantiate the
	 *                      statement list container
	 * @param containeeInit The initialiser that will be used to instantiate the
	 *                      statement that will be added to the constructed
	 *                      container
	 */
	@ParameterizedTest(name = "Statement in middle: {2}")
	@MethodSource("genTestParams")
	public void test_SamePredecessor_DifferentSuccessor(IStatementInitialiser containeeInit,
			IStatementListContainerInitialiser containerInit, String displayName) {
		var slc1 = containerInit.instantiate();
		Assertions.assertTrue(containerInit.initialise(slc1));
		var slc2 = containerInit.instantiate();
		Assertions.assertTrue(containerInit.initialise(slc2));

		// Use 3 statements to make sure that there is always a predecessor and a
		// successor for the statement generated by containeeInit

		var pred1 = this.createMinimalLVS("lv1");
		var st1 = containeeInit.instantiate();
		var succ1 = this.createMinimalLVS("lv2");

		// Make sure that the surrounding statements are not similar
		this.assertSimilarityResult(pred1, succ1, false);
		var sts1 = new Statement[] { pred1, st1, succ1 };

		// Use a new LVS to make sure pred2 and succ2 are not similar
		var pred2 = this.cloneEObj(pred1);
		var st2 = this.cloneEObj(st1);
		var succ2 = this.createMinimalLVS("lv3");

		// Make sure that clones of surrounding statements are not similar
		this.assertSimilarityResult(pred2, succ2, false);
		// Make sure that successors are not similar
		this.assertSimilarityResult(succ2, succ1, false);

		var sts2 = new Statement[] { pred2, st2, succ2 };

		Assertions.assertTrue(containerInit.addStatements(slc1, sts1));
		Assertions.assertTrue(containerInit.addStatements(slc2, sts2));

		this.assertSimilarityResult(pred1, pred2, true);
		this.assertSimilarityResult(pred1, st2, false);
		this.assertSimilarityResult(pred1, succ2, false);

		this.assertSimilarityResult(st1, pred2, false);
		this.assertSimilarityResult(st1, st2, true);
		this.assertSimilarityResult(st1, succ2, false);

		this.assertSimilarityResult(succ1, pred2, false);
		this.assertSimilarityResult(succ1, st2, false);
		this.assertSimilarityResult(succ1, succ2, false);
	}

	/**
	 * Tests if {@link Statement} instances contained by their respective
	 * {@link StatementListContainer} instance are not similar, provided their order
	 * within their container differ.
	 * 
	 * @param displayName   The display name of the test
	 * @param containerInit The initialiser that will be used to instantiate the
	 *                      statement list container
	 * @param containeeInit The initialiser that will be used to instantiate the
	 *                      statement that will be added to the constructed
	 *                      container
	 */
	@ParameterizedTest(name = "Statement in middle: {2}")
	@MethodSource("genTestParams")
	public void test_DifferentPredecessor_DifferentSuccessor(IStatementInitialiser containeeInit,
			IStatementListContainerInitialiser containerInit, String displayName) {
		var containeeCls = containeeInit.getInstanceClassOfInitialiser();

		var slc1 = containerInit.instantiate();
		Assertions.assertTrue(containerInit.initialise(slc1));
		var slc2 = containerInit.instantiate();
		Assertions.assertTrue(containerInit.initialise(slc2));

		// Use 3 statements to make sure that there is always a predecessor and a
		// successor for the statement generated by containeeInit

		var pred1 = this.createMinimalLVS("lv1");
		var st1 = containeeInit.instantiate();
		var succ1 = this.createMinimalLVS("lv2");

		// Make sure that the surrounding statements are not similar
		this.assertSimilarityResult(pred1, succ1, false);
		var sts1 = new Statement[] { pred1, st1, succ1 };

		// PREDECESSOR AND SUCCESSOR ARE INVERTED !!!
		var pred2 = this.cloneEObj(succ1);
		var st2 = this.cloneEObj(st1);
		var succ2 = this.cloneEObj(pred1);

		// Make sure that clones of surrounding statements are not similar
		this.assertSimilarityResult(pred2, succ2, false);
		var sts2 = new Statement[] { pred2, st2, succ2 };

		Assertions.assertTrue(containerInit.addStatements(slc1, sts1));
		Assertions.assertTrue(containerInit.addStatements(slc2, sts2));

		/*
		 * Since similar statements are added in the reverse order, only the statements
		 * generated by containeeInit are similar, if similarity checking ignores their
		 * positioning within their container. The order of the surrounding st variables
		 * never match and they are not similar, as asserted above.
		 */
		for (int i = 0; i < sts1.length; i++) {
			for (int j = 0; j < sts2.length; j++) {
				var cSt1 = sts1[i];
				var cSt2 = sts2[j];

				this.assertSimilarityResult(cSt1, cSt2,
						containeeCls.isAssignableFrom(cSt1.getClass()) && containeeCls.isAssignableFrom(cSt2.getClass())
								&& !this.doesStatementPositionMatter(containeeCls));
			}
		}
	}
}
