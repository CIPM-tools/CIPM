import cipm.consistency.cpr.luapcm.seffreconstruction.SeffReconstructionForward
import org.eclipse.xtext.EcoreUtil2
import org.xtext.lua.lua.Component

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: statementFunctionDeclaration_seff
in reaction to changes in lua
execute actions in pcm

routine assertSeffForFunction(lua::Statement_Function_Declaration functionDeclaration) {
	match {
		require absence of pcm::ResourceDemandingSEFF corresponding to functionDeclaration
	}
	update {
		if (SeffReconstructionForward.needsSeffReconstruction(functionDeclaration)) {
			createSEFF(functionDeclaration)
		}
	}
}

routine createSEFF(lua::Statement_Function_Declaration functionDeclaration) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
		val basicComponent = retrieve pcm::BasicComponent corresponding to EcoreUtil2.getContainerOfType(
			functionDeclaration, Component)
	}
	create {
		val rdseff = new pcm::ResourceDemandingSEFF
	}
	update {
		rdseff.describedService__SEFF = operationSignature
		rdseff.basicComponent_ServiceEffectSpecification = basicComponent

		// seff reconstruction
		SeffReconstructionForward.doReconstruction(functionDeclaration, rdseff)

		addCorrespondenceBetween(functionDeclaration, rdseff)
		basicComponent.serviceEffectSpecifications__BasicComponent += rdseff
	}
}

routine removeCorrespondingSeff(lua::Statement_Function_Declaration functionDeclaration) {
	match {
		val seff = retrieve optional pcm::ResourceDemandingSEFF corresponding to functionDeclaration
	}
	update {
		if (!seff.empty) {
			removeObject(seff.get)
		}
	}
}

//routine createSeffFromImplementingInterfaces(lua::Referenceable classMethod, java::Class javaClass) {
//	match {
//		require absence of pcm::ResourceDemandingSEFF corresponding to classMethod
//	}
//	update {
//		if (classMethod.modifiers.filter(Abstract).size !== 0) {
//			return;
//		}
//		val implementingInterfaces = findImplementingInterfacesFromTypeRefs(javaClass.implements)
//		for (implementingInterface : implementingInterfaces) {
//			createSeffFromImplementingInterface(classMethod, javaClass, implementingInterface)
//		}
//	}
//}
//
//routine createSeffFromImplementingInterface(
//	lua::Referenceable classMethod, java::Class javaClass, java::Interface javaInterface
//) {
//	match {
//		val operationInterface = retrieve pcm::OperationInterface corresponding to javaInterface
//	}
//	update {
//		val methods = javaInterface.methods.filter[hasSameSignature(classMethod)]
//		for (method : methods) {
//			createSEFF(method, javaClass, classMethod)
//		}
//	}
//
//routine checkMembersForOperations(lua::Chunk chunk) {
//	match {
//		retrieve pcm::OperationInterface corresponding to chunk
//	}
//	update {
//		chunk.block.statements.filter[it instanceof Statement_Global_Function_Declaration].forEach [
//			createOrFindPCMSignature(it as Statement_Global_Function_Declaration)
//		]
//	}
//}