import cipm.consistency.cpr.luapcm.seffreconstruction.ActionUtil
import cipm.consistency.cpr.luapcm.seffreconstruction.BranchActionUtil
import org.palladiosimulator.pcm.seff.BranchAction
import org.palladiosimulator.pcm.seff.LoopAction
import org.palladiosimulator.pcm.seff.ProbabilisticBranchTransition
import org.xtext.lua.lua.LuaPackage

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: block_rdBehaviour_internal
in reaction to changes in lua
execute actions in pcm


routine createRDSeff(lua::Block block, lua::Statement_Function_Declaration declaration, pcm::BasicComponent basicComponent, pcm::OperationSignature operationSignature) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
	}
	create {
		val rdSeff = new pcm::ResourceDemandingSEFF
	}
	update {
		logger.debug(block.toString + ": Creating RDSeff")
		rdSeff.basicComponent_ServiceEffectSpecification = basicComponent
		rdSeff.describedService__SEFF = operationSignature

		initializeRDBehaviour(rdSeff, ActionUtil.getBlockName(block))
		addCorrespondenceBetween(rdSeff, block)
		addCorrespondenceBetween(rdSeff, declaration)
		basicComponent.serviceEffectSpecifications__BasicComponent += rdSeff

//		ComponentSetInfoRegistry.getInfosForComponentSet(declaration).declarationToCallingActions.get(declaration).
//			forEach [
//				if (it instanceof InternalCallAction) {
//					logger.debug("InternalCallAction for newly created rd behaviour exists. Registering it.")
//					var internalBehaviour = SeffFactory.eINSTANCE.createResourceDemandingInternalBehaviour
//					internalBehaviour.resourceDemandingSEFF_ResourceDemandingInternalBehaviour = rdSeff
//					it.calledResourceDemandingInternalBehaviour = internalBehaviour
//				}
//			]
	}
}

routine createRDBehaviour(lua::Block block, pcm::AbstractAction parentAction) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
	}
	create {
		val rdBehaviour = new pcm::ResourceDemandingBehaviour
	}
	update {
		logger.debug(block.toString + ": Creating RDBehaviour")
		initializeRDBehaviour(rdBehaviour, ActionUtil.getBlockName(block))
		addCorrespondenceBetween(rdBehaviour, block)
		addRDBehaviourToParentAction(parentAction, rdBehaviour, block)
	}
}

routine addRDBehaviourToParentAction(pcm::AbstractAction parentAction, pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
	update {
		if (parentAction instanceof LoopAction) {
			logger.debug("Adding RD Behaviour to parent loop action")
			val loopAction = parentAction
			loopAction.bodyBehaviour_Loop = rdBehaviour
		} else if (parentAction instanceof BranchAction) {
			if (!addBranchToParentBranchAction(parentAction, rdBehaviour, block)) {
				logger.error("Unable to create branch transitions for branch action")
			}
		}
	}
}

routine addBranchToParentBranchAction(pcm::BranchAction branchAction, pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
//	match {
//		val ifStatement = retrieve optional lua::Statement_If_Then_Else corresponding to branchAction
//	}
	create {
		val branchTransition = new pcm::ProbabilisticBranchTransition
	}
	update {
//		if (ifStatement.empty) {
//			logger.error("Cannot add branch to parent branch action")
//			return
//		}
		logger.debug("Adding Branch to parent branch action")
		branchTransition.setBranchBehaviour_BranchTransition(rdBehaviour)

		// the conditional branches are all block wrappers, so we can use this to determine
		// if the added block is an else block
		val isElseBranch = !block.eContainmentFeature.equals(LuaPackage.Literals.BLOCK_WRAPPER__BLOCK)
		if (isElseBranch) {
			branchTransition.entityName = "ELSE_BRANCH"
		} else {
			branchTransition.entityName = "CONDITIONAL_BRANCH"
		}

		// has this action a synthentic else branch
		val syntheticElseBranch = BranchActionUtil.getSyntheticBranchTransition(branchAction)

		// make sure there is always an else branch (synthetic or not)
		if (syntheticElseBranch.empty && !isElseBranch) {
			addSyntheticElseBranch(branchAction)
		} else if (syntheticElseBranch.present && isElseBranch) {
			removeSyntheticElseBranch(branchAction)
		}

		// add the actual branch transition
		branchAction.branches_Branch.add(branchTransition);

		// make all branches equally probable
		val branchCount = branchAction.branches_Branch.size
		for (branch : branchAction.branches_Branch) {
			(branch as ProbabilisticBranchTransition).setBranchProbability(1.0 / (branchCount as double))
		}
	}
}

routine addSyntheticElseBranch(pcm::BranchAction branchAction) {
	create {
		val syntheticNotTakenBranch = new pcm::ProbabilisticBranchTransition
		val emptyBehaviour = new pcm::ResourceDemandingBehaviour
	}
	update {
		syntheticNotTakenBranch.setBranchBehaviour_BranchTransition(emptyBehaviour)
		syntheticNotTakenBranch.entityName = BranchActionUtil.NAME_SYNTHETIC_ELSE_BRANCH;
		initializeRDBehaviour(emptyBehaviour, "SYNTHETIC_ELSE_BEHAVIOUR")
		branchAction.branches_Branch.add(syntheticNotTakenBranch);
		addCorrespondenceBetween(branchAction, syntheticNotTakenBranch)
	}
}

routine removeSyntheticElseBranch(pcm::BranchAction branchAction) {
	update {
		for (branch : branchAction.branches_Branch) {
			if (branch.entityName == BranchActionUtil.NAME_SYNTHETIC_ELSE_BRANCH) {
				removeCorrespondenceBetween(branchAction, branch)
				branchAction.branches_Branch -= branch

				branch.branchBehaviour_BranchTransition.steps_Behaviour.forEach[removeObject]
				branch.branchBehaviour_BranchTransition.removeObject
				branch.removeObject
			}
		}
	}
}

routine initializeRDBehaviour(pcm::ResourceDemandingBehaviour rdBehaviour, String name) {
	create {
		val startAction = new pcm::StartAction
		val stopAction = new pcm::StopAction
	}
	update {
		startAction.entityName = name + "_START"
		stopAction.entityName = name + "_STOP"

		rdBehaviour.steps_Behaviour += startAction
		rdBehaviour.steps_Behaviour += stopAction
	}
}