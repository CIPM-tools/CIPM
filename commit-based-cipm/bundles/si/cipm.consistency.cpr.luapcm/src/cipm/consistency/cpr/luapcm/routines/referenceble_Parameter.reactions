import org.palladiosimulator.pcm.repository.RepositoryPackage

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: referenceble_parameter
in reaction to changes in lua
execute actions in pcm

routine createParameter(lua::Referenceable functionParameter, lua::Statement_Function_Declaration functionDeclaration) {
	match {
		require absence of pcm::Parameter corresponding to functionParameter
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
		val luaAnyType = retrieve pcm::DataType corresponding to RepositoryPackage.Literals.REPOSITORY
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
	}
	create {
		val pcmParameter = new pcm::Parameter
	}
	update {
		
//		checkCollectionDataTypeCreation(functionParameter.typeReference)
		pcmParameter.operationSignature__Parameter = operationSignature
//		pcmParameter.dataType__Parameter = TypeReferenceCorrespondenceHelper.
//			getDataTypeFromTypeReference(javaParameter.typeReference, correspondenceModel, userInteractor,
//				operationSignature.interface__OperationSignature.repository__Interface)

		pcmParameter.parameterName = functionParameter.name
		pcmParameter.dataType__Parameter = luaAnyType

		operationSignature.parameters__OperationSignature += pcmParameter

		addCorrespondenceBetween(functionParameter, pcmParameter)
//		checkInnerDeclarationsCreation(pcmParameter.dataType__Parameter, javaParameter.typeReference)
	}
}


routine changeParameterName(String newName, lua::Referenceable functionParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to functionParameter
	}
	update {
		// TODO this is broken for some reason
		pcmParameter.parameterName = newName
	}
}

routine deleteParameter(lua::Referenceable functionParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to functionParameter
	}
	update {
		pcmParameter.removeObject
	}
}