import cipm.consistency.cpr.luapcm.seffreconstruction.ActionUtil
import cipm.consistency.cpr.luapcm.seffreconstruction.SeffReconstruction
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.palladiosimulator.pcm.seff.ExternalCallAction
import org.xtext.lua.LuaUtil

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: statement_actions
in reaction to changes in lua
execute actions in pcm

routine createActionsForStatement(lua::Statement statement, lua::Block block) {
	match {
		require absence of pcm::AbstractAction corresponding to statement
//		val blockActions = retrieve many pcm::AbstractAction corresponding to block
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		val statementActions = SeffReconstruction.getActionsForStatement(statement, correspondenceModel)
		if (statementActions.size < 1) {
			return
		}

		logger.info(String.format("%s: %d action(s) reconstructed", statement, statementActions.size()))

		val componentOfStatement = LuaUtil.getComponent(statement)
		statementActions.forEach [
			addCorrespondenceBetween(it, statement)

			if (it instanceof ExternalCallAction) {
				logger.info("External call was found")
				registerExternalCallAction(it, rdBehaviour, componentOfStatement)
			}
		]

		// chain the new actions into the step behaviour
		val firstNewAction = statementActions.get(0)
		val previousAction = ActionUtil.getPreviousActionOfStatement(statement, block, rdBehaviour, correspondenceModel);
		ActionUtil.chainActions(previousAction, firstNewAction)

		val lastNewAction = statementActions.get(statementActions.size() - 1)
		val subsequentAction = ActionUtil.getSubsequentActionOfStatement(statement, block, rdBehaviour, correspondenceModel);
		ActionUtil.chainActions(lastNewAction, subsequentAction)

		val insertionIndex = rdBehaviour.steps_Behaviour.indexOf(previousAction) + 1
		rdBehaviour.steps_Behaviour.addAll(insertionIndex, statementActions)
	}
}

routine removeActionsForStatement(lua::Statement statement, lua::Block block) {
	match {
		val statementActions = retrieve many pcm::AbstractAction corresponding to statement
	}
	update {
		if (statementActions.size > 0) {
			logger.info(String.format("Statement with actions removed: %s", statement))
			statementActions.forEach [
				removeActionFromStepBehaviourOfBlock(it, block)
			]
		}
	}
}

routine removeActionFromStepBehaviourOfBlock(pcm::AbstractAction action, lua::Block block) {
	match {
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		if (!rdBehaviour.present) {
			logger.error(action + ": Parent block has no corresponding step behaviour")
			return
		}

		logger.info(action.toString + ": Removing action from step behaviour" + rdBehaviour.toString)

		// trigger other clean up actions
		if (action instanceof ExternalCallAction) {
			deregisterExternalCallAction(action)
		}

		// fix the chaining of the remaining actions
		val pred = action.getPredecessor_AbstractAction()
		val succ = action.getPredecessor_AbstractAction()
		pred.setSuccessor_AbstractAction(succ);
		succ.setPredecessor_AbstractAction(pred);

		rdBehaviour.get.steps_Behaviour -= action

		removeCorrespondenceBetween(action, block)
		action.removeObject
	}
}

routine registerExternalCallAction(pcm::ExternalCallAction action, pcm::ResourceDemandingBehaviour rdseff, lua::Component callingComponent) {
	match {
		val calledComponent = retrieve optional lua::Component corresponding to action
	}
	update {
		if (calledComponent.present) {
			findOrCreateOperationRequiredRole(action, callingComponent, calledComponent.get)
		} else {
			logger.error("ExternalCall action is missing component correspondences: " + action.toString)
		}
	}
}

routine findOrCreateOperationRequiredRole(pcm::ExternalCallAction action, lua::Component callingComponent, lua::Component calledComponent) {
	match {
		val existingRole = retrieve optional pcm::OperationRequiredRole corresponding to action
		val requiredInterface = retrieve optional pcm::OperationInterface corresponding to calledComponent
		val pcmCallingComponent = retrieve optional pcm::BasicComponent corresponding to callingComponent
	}
	update {
		if (existingRole.present) {
			logger.warn("External action is already associated with a required role")
			return;
		}

		if (requiredInterface.present && pcmCallingComponent.present) {
			// is there already a role for calls from this component to the called component?
			// -> then use it
			val existingRoleForInterface = pcmCallingComponent.get.requiredRoles_InterfaceRequiringEntity.stream().
				filter [
					(it as OperationRequiredRole).requiredInterface__OperationRequiredRole.equals(requiredInterface)
				].findAny

			if (existingRoleForInterface.present) {
				logger.info("Found role for requiring interface")
				addCorrespondenceBetween(action, existingRoleForInterface.get)

			} else {
				logger.info("Required role needs to be created")
				createOperationRequiredRole(action, pcmCallingComponent.get, requiredInterface.get)
			}
		} else {
			logger.error("Unable to find required interface or calling component for creating a required role")
		}
	}
}

routine createOperationRequiredRole(pcm::ExternalCallAction action, pcm::BasicComponent pcmCallingComponent, pcm::OperationInterface requiredInterface) {
	match {
		val calledComponent = retrieve pcm::BasicComponent corresponding to requiredInterface
	}
	create {
		val operationRequiredRole = new pcm::OperationRequiredRole
	}
	update {
		logger.info("Creating OperationRequiredRole")
		operationRequiredRole.requiringEntity_RequiredRole = pcmCallingComponent
		operationRequiredRole.requiredInterface__OperationRequiredRole = requiredInterface
		operationRequiredRole.entityName = calledComponent.entityName + "_requiring_role"

		// add the role to the calling component
		pcmCallingComponent.requiredRoles_InterfaceRequiringEntity += operationRequiredRole

		// make sute the action uses the role
		action.role_ExternalService = operationRequiredRole
		addCorrespondenceBetween(action, operationRequiredRole)
	}
}

routine deregisterExternalCallAction(pcm::ExternalCallAction action) {
	match {
		val operationRequiredRole = retrieve pcm::OperationRequiredRole corresponding to action
		val allActionsOfRequiredRole = retrieve many pcm::ExternalCallAction corresponding to operationRequiredRole
	}
	update {
		logger.info("Removing OperationRequiredRole")
		removeCorrespondenceBetween(operationRequiredRole, action)

		// if there were no other corresponding actions, we delete the role	
		if (allActionsOfRequiredRole.size == 1) {
			operationRequiredRole.removeObject
		}
	}
}