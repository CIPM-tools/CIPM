import cipm.consistency.cpr.luapcm.seffreconstruction.ActionUtil
import cipm.consistency.cpr.luapcm.seffreconstruction.CorrespondenceUtil
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.palladiosimulator.pcm.seff.ExternalCallAction
import org.palladiosimulator.pcm.seff.InternalAction
import org.xtext.lua.LuaUtil
import org.xtext.lua.lua.Statement
import cipm.consistency.cpr.luapcm.seffreconstruction.ActionReconstruction

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: statement_actions
in reaction to changes in lua
execute actions in pcm

routine createActionsForStatement(lua::Statement statement, lua::Block block) {
	match {
		require absence of pcm::AbstractAction corresponding to statement
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		val statementActions = ActionReconstruction.getActionsForStatement(statement, correspondenceModel)
		if (statementActions.size < 1) {
			return
		}
		logger.debug(String.format("%s: %d action(s) reconstructed", statement, statementActions.size()))

		var previousAction = ActionUtil.getPreviousActionOfStatement(statement, block, rdBehaviour,
			correspondenceModel);
		var subsequentAction = ActionUtil.getSubsequentActionOfStatement(statement, block, rdBehaviour,
			correspondenceModel);

		// every new action is possibly fused with this action
		var actionToCheckForFusing = previousAction;

		// insert the actions of the statement into the step behaviour
		// TODO do internal action merging here
		var insertionIndex = rdBehaviour.steps_Behaviour.indexOf(previousAction) + 1

		for (action : statementActions) {
			addCorrespondenceBetween(action, statement)
			if (actionToCheckForFusing instanceof InternalAction && action instanceof InternalAction) {
				// we fuse with the previous internal action and don't need a separate internal action here
				fuseTwoInternalActions(actionToCheckForFusing as InternalAction, action as InternalAction)
			} else {
				if (action instanceof ExternalCallAction) {
					logger.debug("External call was found")
					val componentOfStatement = LuaUtil.getComponent(statement)
					registerExternalCallAction(action, rdBehaviour, componentOfStatement)
				}

				logger.debug("Action is added to step behaviour")
				// insert the action into the step behaviour
				ActionUtil.chainActions(previousAction, action)
				rdBehaviour.steps_Behaviour.add(insertionIndex, action)
				insertionIndex += 1
				actionToCheckForFusing = action
			}
		}

		// possibly fuse the last action with the subsequent action
		// we don't fuse the previousAction and the subsequentAction
		// (because that would imply the are both InternalActions which should not happen)
		if (actionToCheckForFusing !== previousAction && actionToCheckForFusing instanceof InternalAction &&
			subsequentAction instanceof InternalAction) {
			logger.debug("Fusing last statement action with subsequent action")
			fuseTwoInternalActions(actionToCheckForFusing as InternalAction, subsequentAction as InternalAction)
		} else {
			ActionUtil.chainActions(actionToCheckForFusing, subsequentAction)
		}
	}
}

routine fuseTwoInternalActions(pcm::InternalAction a, pcm::InternalAction b) {
	match {
		val statementsCorrespondingToB = retrieve many lua::Statement corresponding to b
	}
	update {
		logger.debug("Fusing two internal actions")
		// transfer the correspondences from b to a and delete b
		statementsCorrespondingToB.forEach [
			addCorrespondenceBetween(a, it)
			b.removeCorrespondenceBetween(it)
		]
		b.removeObject

		//
		var newStatementCount = CorrespondenceUtil.getCorrespondingEObjectsByType(correspondenceModel, a, Statement).
			size()
		a.entityName = String.format("Internal: %d statements", newStatementCount)
	}
}

routine removeActionsForStatement(lua::Statement statement, lua::Block block) {
	match {
		val statementActions = retrieve many pcm::AbstractAction corresponding to statement
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		logger.debug(String.format("Statement with actions removed: %s", statement))
		for (action : statementActions) {
			action.removeCorrespondenceBetween(statement)
			// delete if the action has no other corresponding statements
			tryDeleteAction(action, rdBehaviour)
		}
	}
}

routine tryDeleteAction(pcm::AbstractAction action, pcm::ResourceDemandingBehaviour rdBehaviour) {
	match {
		val correspondingStatementsOfAction = retrieve many lua::Statement corresponding to action
	}
	update {
		if (correspondingStatementsOfAction.size == 0) {
			rdBehaviour.steps_Behaviour -= action
			action.removeObject
		}
	}
}

routine removeActionFromStepBehaviourOfBlock(pcm::AbstractAction action, lua::Block block) {
	match {
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		if (!rdBehaviour.present) {
			logger.error(action + ": Parent block has no corresponding step behaviour")
			return
		}

		logger.debug(action.toString + ": Removing action from step behaviour" + rdBehaviour.toString)

		// trigger other clean up actions
		if (action instanceof ExternalCallAction) {
			deregisterExternalCallAction(action)
		}

		// fix the chaining of the remaining actions
		val pred = action.getPredecessor_AbstractAction()
		val succ = action.getPredecessor_AbstractAction()
		pred.setSuccessor_AbstractAction(succ);
		succ.setPredecessor_AbstractAction(pred);

		rdBehaviour.get.steps_Behaviour -= action

		removeCorrespondenceBetween(action, block)
		action.removeObject
	}
}

routine registerExternalCallAction(pcm::ExternalCallAction action, pcm::ResourceDemandingBehaviour rdseff, lua::Component callingComponent) {
	match {
		val calledComponent = retrieve optional lua::Component corresponding to action
	}
	update {
		if (calledComponent.present) {
			findOrCreateOperationRequiredRole(action, callingComponent, calledComponent.get)
		} else {
			logger.error("ExternalCall action is missing component correspondences: " + action.toString)
		}
	}
}

routine findOrCreateOperationRequiredRole(pcm::ExternalCallAction action, lua::Component callingComponent, lua::Component calledComponent) {
	match {
		val existingRole = retrieve optional pcm::OperationRequiredRole corresponding to action
		val requiredInterface = retrieve optional pcm::OperationInterface corresponding to calledComponent
		val pcmCallingComponent = retrieve optional pcm::BasicComponent corresponding to callingComponent
	}
	update {
		if (existingRole.present) {
			logger.warn("External action is already associated with a required role")
			return
		}

		if (requiredInterface.present && pcmCallingComponent.present) {
			// is there already a role for calls from this component to the called component?
			// -> then use it
			val existingRequiredRoleForInterface = pcmCallingComponent.get.requiredRoles_InterfaceRequiringEntity.stream().
				filter [
					requiredInterface.get.equals((it as OperationRequiredRole).requiredInterface__OperationRequiredRole)
				].map[
					it as OperationRequiredRole
				].findAny

			if (existingRequiredRoleForInterface.present) {
				logger.debug("Found role for requiring interface")
				bindExternalCallAndRequiredRole(action, existingRequiredRoleForInterface.get)

			} else {
				logger.debug("Required role needs to be created")
				createOperationRequiredRole(action, pcmCallingComponent.get, requiredInterface.get)
			}
		} else {
			logger.warn("Unable to find required interface or calling component for creating a required role")
		}
	}
}

routine createOperationRequiredRole(pcm::ExternalCallAction action, pcm::BasicComponent pcmCallingComponent, pcm::OperationInterface requiredInterface) {
	match {
		val calledComponent = retrieve pcm::BasicComponent corresponding to requiredInterface
	}
	create {
		val operationRequiredRole = new pcm::OperationRequiredRole
	}
	update {
		logger.debug("Creating OperationRequiredRole")
		operationRequiredRole.requiringEntity_RequiredRole = pcmCallingComponent
		operationRequiredRole.requiredInterface__OperationRequiredRole = requiredInterface
		operationRequiredRole.entityName = calledComponent.entityName + "_requiring_role"

		// add the role to the calling component
		pcmCallingComponent.requiredRoles_InterfaceRequiringEntity += operationRequiredRole

		// make sure the action uses the role
		bindExternalCallAndRequiredRole(action, operationRequiredRole)
	}
}

routine bindExternalCallAndRequiredRole(pcm::ExternalCallAction action, pcm::OperationRequiredRole requiredRole) {
	update {
		action.role_ExternalService = requiredRole
		addCorrespondenceBetween(action, requiredRole)
	}
}

routine deregisterExternalCallAction(pcm::ExternalCallAction action) {
	match {
		val operationRequiredRole = retrieve pcm::OperationRequiredRole corresponding to action
		val allActionsOfRequiredRole = retrieve many pcm::ExternalCallAction corresponding to operationRequiredRole
	}
	update {
		logger.debug("Removing OperationRequiredRole")
		removeCorrespondenceBetween(operationRequiredRole, action)

		// if there were no other corresponding actions, we delete the role	
		if (allActionsOfRequiredRole.size == 1) {
			operationRequiredRole.removeObject
		}
	}
}