import cipm.consistency.cpr.luapcm.seffreconstruction.BranchActionUtil
import org.eclipse.xtext.EcoreUtil2
import org.palladiosimulator.pcm.seff.BranchAction
import org.palladiosimulator.pcm.seff.LoopAction
import org.palladiosimulator.pcm.seff.ProbabilisticBranchTransition
import org.xtext.lua.LuaUtil
import org.xtext.lua.lua.LuaPackage
import org.xtext.lua.lua.Statement
import org.xtext.lua.lua.Statement_Function_Declaration

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: block_rdBehaviour
in reaction to changes in lua
execute actions in pcm

routine addedSeffBlock(lua::Block block) {
	match {
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		logger.info("foo")
		if (rdBehaviour.present) {
			logger.warn(block.toString + ": RD behaviour already exists")
			return
		}

		val parentStatement = EcoreUtil2.getContainerOfType(block, Statement)
		if (parentStatement instanceof Statement_Function_Declaration) {
			// create the RDSEFF for the block
			createRDSeff(block)
		} else {
			// create the RDBehaviour for the block
			createRDBehaviour(block)
		}
	}
}

routine createRDSeff(lua::Block block) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
		val basicComponent = retrieve optional pcm::BasicComponent corresponding to LuaUtil.getComponent(block)
		val operationSignature = retrieve optional pcm::OperationSignature corresponding to LuaUtil.
			getDeclaration(block)
	}
	create {
		val rdSeff = new pcm::ResourceDemandingSEFF
	}
	update {
		if (!basicComponent.present) {
			logger.warn("Component of Block has no corresponding basic component")
			return
		}
		if (!operationSignature.present) {
			logger.warn("Declaration of Block has no corresponding operation signature")
			return
		}

		logger.debug(block.toString + ": Creating RDSeff")
		rdSeff.basicComponent_ServiceEffectSpecification = basicComponent.get
		rdSeff.describedService__SEFF = operationSignature.get

		initializeRDBehaviour(rdSeff, block.toString)
		addCorrespondenceBetween(rdSeff, block)

		basicComponent.get.serviceEffectSpecifications__BasicComponent += rdSeff
	}
}

routine createRDBehaviour(lua::Block block) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
		val parentAction = retrieve optional pcm::AbstractAction corresponding to EcoreUtil2.
			getContainerOfType(block, Statement)
	}
	create {
		val rdBehaviour = new pcm::ResourceDemandingBehaviour
	}
	update {
		logger.debug(block.toString + ": Creating RDBehaviour")
		initializeRDBehaviour(rdBehaviour, block.toString)
		addCorrespondenceBetween(rdBehaviour, block)

		if (parentAction.present) {
			addRDBehaviourToParentAction(parentAction.get, rdBehaviour, block)
		} else {
			logger.warn("No parent action for block")
		}
	}
}

routine addRDBehaviourToParentAction(pcm::AbstractAction parentAction, pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
	update {
		if (parentAction instanceof LoopAction) {
			logger.debug("Adding RD Behaviour to parent loop action")
			val loopAction = parentAction
			loopAction.bodyBehaviour_Loop = rdBehaviour
		} else if (parentAction instanceof BranchAction) {
			if (!addBranchToParentBranchAction(parentAction, rdBehaviour, block)) {
				logger.error("Unable to create branch transitions for branch action")
			}
		}
	}
}

routine addBranchToParentBranchAction(pcm::BranchAction branchAction, pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
	match {
		val ifStatement = retrieve lua::Statement_If_Then_Else corresponding to branchAction
	}
	create {
		val branchTransition = new pcm::ProbabilisticBranchTransition
	}
	update {
		logger.debug("Adding Branch to parent branch action")
		branchTransition.setBranchBehaviour_BranchTransition(rdBehaviour)

		// the conditional branches are all block wrappers, so we can use this to determine
		// if the added block is an else block
		val isElseBranch = !block.eContainmentFeature.equals(LuaPackage.Literals.BLOCK_WRAPPER__BLOCK)
		if (isElseBranch) {
			branchTransition.entityName = "ELSE_BRANCH"
		} else {
			branchTransition.entityName = "CONDITIONAL_BRANCH"
		}

		// has this action a synthentic else branch
		val syntheticElseBranch = BranchActionUtil.getSyntheticBranchTransition(branchAction)

		// make sure there is always an else branch (synthetic or not)
		if (syntheticElseBranch.empty && !isElseBranch) {
			addSyntheticElseBranch(branchAction)
		} else if (syntheticElseBranch.present && isElseBranch) {
			removeSyntheticElseBranch(branchAction)
		}

		// add the actual branch transition
		branchAction.branches_Branch.add(branchTransition);

		// make all branches equally probable
		val branchCount = branchAction.branches_Branch.size
		for (branch : branchAction.branches_Branch) {
			(branch as ProbabilisticBranchTransition).setBranchProbability(1.0 / (branchCount as double))
		}
	}
}

routine addSyntheticElseBranch(pcm::BranchAction branchAction) {
	create {
		val syntheticNotTakenBranch = new pcm::ProbabilisticBranchTransition
		val emptyBehaviour = new pcm::ResourceDemandingBehaviour
	}
	update {
		syntheticNotTakenBranch.setBranchBehaviour_BranchTransition(emptyBehaviour)
		syntheticNotTakenBranch.entityName = BranchActionUtil.NAME_SYNTHETIC_ELSE_BRANCH;
		initializeRDBehaviour(emptyBehaviour, "SYNTHETIC_ELSE_BEHAVIOUR")
		branchAction.branches_Branch.add(syntheticNotTakenBranch);
		addCorrespondenceBetween(branchAction, syntheticNotTakenBranch)
	}
}

routine removeSyntheticElseBranch(pcm::BranchAction branchAction) {
	update {
		for (branch : branchAction.branches_Branch) {
			if (branch.entityName == BranchActionUtil.NAME_SYNTHETIC_ELSE_BRANCH) {
				removeCorrespondenceBetween(branchAction, branch)
				branchAction.branches_Branch -= branch

				branch.branchBehaviour_BranchTransition.steps_Behaviour.forEach[removeObject]
				branch.branchBehaviour_BranchTransition.removeObject
				branch.removeObject
			}
		}
	}
}

routine initializeRDBehaviour(pcm::ResourceDemandingBehaviour rdBehaviour, String name) {
	create {
		val startAction = new pcm::StartAction
		val stopAction = new pcm::StopAction
	}
	update {

		startAction.entityName = name + "_START"
		stopAction.entityName = name + "_STOP"

		rdBehaviour.steps_Behaviour += startAction
		rdBehaviour.steps_Behaviour += stopAction
	}
}

routine removedSeffBlock(lua::Block block) {
	match {
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		logger.debug(block.toString + ": Block deleted -> Removing RD Behaviour")
		removeCorrespondenceBetween(rdBehaviour, block)
		rdBehaviour.removeObject
	}
}