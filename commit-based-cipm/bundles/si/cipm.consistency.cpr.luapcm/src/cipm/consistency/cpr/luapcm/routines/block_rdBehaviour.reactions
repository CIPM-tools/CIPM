import org.eclipse.xtext.EcoreUtil2
import org.palladiosimulator.pcm.seff.BranchAction
import org.palladiosimulator.pcm.seff.LoopAction
import org.xtext.lua.LuaUtil
import org.xtext.lua.lua.Statement
import org.xtext.lua.lua.Statement_Function_Declaration

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: block_stepsBehaviour
in reaction to changes in lua
execute actions in pcm

routine addedSeffBlock(lua::Block block) {
	match {
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		if (rdBehaviour.present) {
			logger.warn(block.toString + ": RD behaviour already exists")
			return
		}

		val parentStatement = EcoreUtil2.getContainerOfType(block, Statement)
		if (parentStatement instanceof Statement_Function_Declaration) {
			// create the RDSEFF for the block
			createRDSeff(block)
		} else {
			// create the RDBehaviour for the block
			createRDBehaviour(block)
		}
	}
}

routine createRDSeff(lua::Block block) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
		val basicComponent = retrieve optional pcm::BasicComponent corresponding to LuaUtil.getComponent(block)
		val operationSignature = retrieve optional pcm::OperationSignature corresponding to LuaUtil.
			getDeclaration(block)
	}
	create {
		val rdSeff = new pcm::ResourceDemandingSEFF
	}
	update {
		if (!basicComponent.present) {
			logger.warn("Component of Block has no corresponding basic component")
			return
		}
		if (!operationSignature.present) {
			logger.warn("Declaration of Block has no corresponding operation signature")
			return
		}

		logger.info(block.toString + ": Creating RDSeff")
		rdSeff.basicComponent_ServiceEffectSpecification = basicComponent.get
		rdSeff.describedService__SEFF = operationSignature.get

		initializeRDBehaviour(rdSeff, block)

		basicComponent.get.serviceEffectSpecifications__BasicComponent += rdSeff
	}
}

routine createRDBehaviour(lua::Block block) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
		val parentAction = retrieve optional pcm::AbstractAction corresponding to EcoreUtil2.
			getContainerOfType(block, Statement)
	}
	create {
		val rdBehaviour = new pcm::ResourceDemandingBehaviour
	}
	update {
		logger.info(block.toString + ": Creating RDBehaviour")
		initializeRDBehaviour(rdBehaviour, block)

		if (!parentAction.present) {
			logger.warn("No parent action for block")
			return
		}

		if (parentAction.get instanceof LoopAction) {
			logger.info("Adding RD Behaviour to parent loop action")
			val loopAction = parentAction.get as LoopAction
			loopAction.bodyBehaviour_Loop = rdBehaviour
		} else if (parentAction.get instanceof BranchAction) {
			logger.info("Adding RD Behaviour to parent branch action")
			if (!createBranchForBlock(parentAction.get as BranchAction, rdBehaviour, block)) {
				logger.error("Unable to create branch transitions for branch action")
			}
		} else {
			logger.warn("NOT implemented: Adding rd behaviour to this type abstract action " + parentAction.class.name)
		}
	}
}

routine createBranchForBlock(pcm::BranchAction branchAction, pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
	match {
		val ifStatement = retrieve lua::Statement_If_Then_Else corresponding to branchAction
	}
	create {
		val branchTransition = new pcm::ProbabilisticBranchTransition
	}
	update {
		var branchCount = 0
		if (ifStatement.elseBlock !== null) {
			branchCount += 1
		}
		if (ifStatement.block !== null) {
			branchCount += 1
		}
		branchCount += ifStatement.elseIf.length

		branchTransition.setBranchProbability(1.0 / (branchCount as double));
		branchTransition.setBranchBehaviour_BranchTransition(rdBehaviour);
		branchAction.branches_Branch.add(branchTransition);
	}
}

routine initializeRDBehaviour(pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
	create {
		val startAction = new pcm::StartAction
		val stopAction = new pcm::StopAction
	}
	update {
		addCorrespondenceBetween(rdBehaviour, block)

		startAction.entityName = block.toString
		stopAction.entityName = block.toString

		rdBehaviour.steps_Behaviour += startAction
		rdBehaviour.steps_Behaviour += stopAction
	}
}

routine removedSeffBlock(lua::Block block) {
	match {
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		logger.info(block.toString + ": Block deleted -> Removing RD Behaviour")
		removeCorrespondenceBetween(rdBehaviour, block)
		rdBehaviour.removeObject
	}
}