import cipm.consistency.base.models.instrumentation.InstrumentationModel.InstrumentationType
import cipm.consistency.cpr.pcmim.InternalUtils
import org.palladiosimulator.pcm.seff.BranchAction
import org.palladiosimulator.pcm.seff.ExternalCallAction
import org.palladiosimulator.pcm.seff.InternalAction
import org.palladiosimulator.pcm.seff.InternalCallAction
import org.palladiosimulator.pcm.seff.LoopAction

import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm
import "http://www.dmodel.com/InstrumentationMetamodel" as im

reactions: actionInstrumentationPoints
in reaction to changes in pcm
execute actions in im

reaction ActionAdded {
	after element pcm::AbstractAction inserted in pcm::ResourceDemandingBehaviour[steps_Behaviour]
	call {
		var Integer actionType
		if (newValue instanceof LoopAction) {
			actionType = InstrumentationType.LOOP_VALUE
		} else if (newValue instanceof BranchAction) {
			actionType = InstrumentationType.BRANCH_VALUE
		} else if (newValue instanceof InternalAction) {
			actionType = InstrumentationType.INTERNAL_VALUE
		} else if (newValue instanceof InternalCallAction) {
			actionType = InstrumentationType.INTERNAL_CALL_VALUE
		} else if (newValue instanceof ExternalCallAction) {
			actionType = InstrumentationType.EXTERNAL_CALL_VALUE
		} else {
			return
		}

		var seff = InternalUtils.getParentSEFFNotForInternalBehaviour(affectedEObject)
		if (seff !== null) {
			createOrFindActionInstrumentationPoint(seff, newValue, actionType)
		}
	}
}

routine createOrFindActionInstrumentationPoint(pcm::ResourceDemandingSEFF seff, pcm::AbstractAction absAction, Integer typeValue) {
	match {
		require absence of im::ActionInstrumentationPoint corresponding to absAction
		val sip = retrieve im::ServiceInstrumentationPoint corresponding to seff
	}
	create {
		val aip = new im::ActionInstrumentationPoint
	}
	update {
		aip.active = true
		aip.^action = absAction
		aip.type = InstrumentationType.get(typeValue)

		sip.actionInstrumentationPoints += aip

		addCorrespondenceBetween(aip, absAction)
	}
}

reaction ActionRemoved {
	after element pcm::AbstractAction removed from pcm::ResourceDemandingBehaviour[steps_Behaviour]
	call {
		var seff = InternalUtils.getParentSEFFNotForInternalBehaviour(affectedEObject)
		if (seff !== null) {
			checkRemovalOfActionInstrumentationPoint(oldValue, seff)
		}
	}
}

routine checkRemovalOfActionInstrumentationPoint(pcm::AbstractAction absAction, pcm::ResourceDemandingSEFF seff) {
	match {
		val sip = retrieve im::ServiceInstrumentationPoint corresponding to seff
	}
	update {
		val aips = sip.actionInstrumentationPoints.filter[it.^action === null || it.^action.eIsProxy].toSet
		if (aips !== null && !aips.empty) {
			for (ai : aips) {
				ai.removeObject
			}
		}
		checkRemovalOfNonProxyActionInstrumentationPoint(absAction)
	}
}

routine checkRemovalOfNonProxyActionInstrumentationPoint(pcm::AbstractAction absAction) {
	match {
		val aip = retrieve im::ActionInstrumentationPoint corresponding to absAction
	}
	update aip.removeObject
}