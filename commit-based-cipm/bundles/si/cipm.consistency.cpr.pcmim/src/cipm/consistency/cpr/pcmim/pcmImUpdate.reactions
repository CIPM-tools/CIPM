import cipm.consistency.base.models.instrumentation.InstrumentationModel.InstrumentationModelPackage
import cipm.consistency.base.models.instrumentation.InstrumentationModel.InstrumentationType
import cipm.consistency.cpr.pcmim.InternalUtils

import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm
import "http://www.dmodel.com/InstrumentationMetamodel" as im

reactions: pcmImUpdate
in reaction to changes in pcm
execute actions in im

reaction AddedSEFF {
	after element pcm::ResourceDemandingSEFF inserted in pcm::BasicComponent[serviceEffectSpecifications__BasicComponent]
	call createOrFindServiceInstrumentationPoint(newValue)
}

routine createOrFindServiceInstrumentationPoint(pcm::ResourceDemandingSEFF seff) {
	match {
		require absence of im::ServiceInstrumentationPoint corresponding to seff
		val insModel = retrieve im::InstrumentationModel corresponding to InstrumentationModelPackage.Literals.
			INSTRUMENTATION_MODEL
	}
	create {
		val sip = new im::ServiceInstrumentationPoint
	}
	update {
		logger.debug("Adding SIP for: " + seff.describedService__SEFF.entityName + " " + seff.id)
		sip.active = true
		sip.service = seff
		addCorrespondenceBetween(sip, seff)
		insModel.points += sip
	}
}

reaction RemovedSEFF {
	after element pcm::ResourceDemandingSEFF removed from pcm::BasicComponent[serviceEffectSpecifications__BasicComponent]
	call checkRemovalOfServiceInstrumentationPoint(oldValue)
}

routine checkRemovalOfServiceInstrumentationPoint(pcm::ResourceDemandingSEFF seff) {
	match {
		val im = retrieve im::InstrumentationModel corresponding to InstrumentationModelPackage.Literals.
			INSTRUMENTATION_MODEL
	}
	update {
		logger.debug("Removing SIP for: " + seff.describedService__SEFF.entityName + " " + seff.id)
		val sips = im.points.filter[it.service === null || it.service.eIsProxy].toSet
		if (sips !== null && !sips.empty) {
			for (si : sips) {
				si.removeObject
			}
		}
		checkRemovalOfNonProxyServiceInstrumentationPoint(seff)
	}
}

routine checkRemovalOfNonProxyServiceInstrumentationPoint(pcm::ResourceDemandingSEFF seff) {
	match {
		val sip = retrieve im::ServiceInstrumentationPoint corresponding to seff
	}
	update {
//		for (aip : sip.actionInstrumentationPoints) {
//			aip.removeObject
//		}
		sip.removeObject
	}
}

reaction ActionAdded {
	after element pcm::AbstractAction inserted in pcm::ResourceDemandingBehaviour[steps_Behaviour]
	call {
		val actionType = InternalUtils.abstractActionToActionTypeValue(newValue)
		var seff = InternalUtils.getParentSEFFNotForInternalBehaviour(affectedEObject)
		if (seff !== null && actionType !== -1) {
			createOrFindActionInstrumentationPoint(seff, newValue, actionType)
		}
	}
}

routine createOrFindActionInstrumentationPoint(pcm::ResourceDemandingSEFF seff, pcm::AbstractAction absAction, Integer typeValue) {
	match {
		require absence of im::ActionInstrumentationPoint corresponding to absAction
		val sip = retrieve im::ServiceInstrumentationPoint corresponding to seff
	}
	create {
		val aip = new im::ActionInstrumentationPoint
	}
	update {
		logger.info("Added AIP for action: " + absAction.id)
		aip.active = true
		aip.^action = absAction
		addCorrespondenceBetween(aip, absAction)
		aip.type = InstrumentationType.get(typeValue)

		sip.actionInstrumentationPoints += aip
	}
}

reaction ActionRemoved {
	after element pcm::AbstractAction removed from pcm::ResourceDemandingBehaviour[steps_Behaviour]
//	after element pcm::AbstractAction deleted
	call {
		var seff = InternalUtils.getParentSEFFNotForInternalBehaviour(affectedEObject)
		if (seff !== null) {
			checkRemovalOfActionInstrumentationPoint(oldValue, seff)
//			return
		}

		if (!checkRemovalOfNonProxyActionInstrumentationPoint(oldValue)) {
			logger.error("Unable to remove action instrumentation point for " + affectedEObject + " (cannot determine SEFF)")
		}
	}
}

routine checkRemovalOfActionInstrumentationPoint(pcm::AbstractAction absAction, pcm::ResourceDemandingSEFF seff) {
	match {
		val sip = retrieve optional im::ServiceInstrumentationPoint corresponding to seff
	}
	update {
		if (sip.present) {
			val aips = sip.get.actionInstrumentationPoints.filter[it.^action === null || it.^action.eIsProxy].toSet
			if (aips !== null && !aips.empty) {
				for (ai : aips) {
					ai.removeObject
				}
			}
		} else {
			logger.warn("Cannot find SIP for SEFF")
		}
		checkRemovalOfNonProxyActionInstrumentationPoint(absAction)
	}
}

routine checkRemovalOfNonProxyActionInstrumentationPoint(pcm::AbstractAction absAction) {
	match {
		val aip = retrieve optional im::ActionInstrumentationPoint corresponding to absAction
	}
	update {
		if (aip.present) {
			logger.info("Removing AIP for: " + absAction + " " + absAction.id)
			removeCorrespondenceBetween(aip.get, absAction)
			aip.get.removeObject
		} else {
			logger.warn("Cannot delete action without correspondence")
		}
	}
}