import org.eclipse.xtext.EcoreUtil2
import org.xtext.lua.lua.Chunk
import org.xtext.lua.lua.Referenceable

//import static tools.vitruv.applications.pcmjava.util.java2pcm.TypeReferenceCorrespondenceHelper.*
import static extension edu.kit.ipd.sdq.commons.util.org.palladiosimulator.pcm.repository.ParameterUtil.*
//import static extension tools.vitruv.applications.util.temporary.java.JavaMemberAndParameterUtil.hasSameSignature
//import static tools.vitruv.applications.util.temporary.java.JavaTypeUtil.*
//import tools.vitruv.applications.pcmjava.util.java2pcm.TypeReferenceCorrespondenceHelper
//import org.emftext.language.java.parameters.OrdinaryParameter
//import org.emftext.language.java.members.Method
//import org.emftext.language.java.modifiers.Abstract

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: commonSignature
in reaction to changes in lua
execute actions in pcm

//import commonDataType
//routine createOrFindPCMSignature(lua::Statement_Declaration functionDeclaration) {
routine createOrFindPCMSignature(lua::Referenceable functionDeclaration) {
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to EcoreUtil2.<Chunk>getContainerOfType(
			functionDeclaration, Chunk)
		require absence of pcm::OperationSignature corresponding to functionDeclaration
	}
	update {
		createPCMSignature(functionDeclaration)
	}
}

routine createPCMSignature(lua::Referenceable functionDeclaration) {
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to EcoreUtil2.<Chunk>getContainerOfType(
			functionDeclaration, Chunk)
		require absence of pcm::OperationSignature corresponding to functionDeclaration
	}
	create {
		val operationSignature = new pcm::OperationSignature
	}
	update {
		operationSignature.entityName = functionDeclaration.name
		operationSignature.interface__OperationSignature = pcmInterface
		pcmInterface.signatures__OperationInterface += operationSignature
		addCorrespondenceBetweenMethodAndOperationSignature(functionDeclaration, operationSignature)
	}
}

routine addCorrespondenceBetweenMethodAndOperationSignature(lua::Referenceable functionDeclaration, pcm::OperationSignature sign) {
	update {
		addCorrespondenceBetween(sign, functionDeclaration)
	}
}

routine checkMembersForOperations(lua::Chunk chunk) {
	match {
		retrieve pcm::OperationInterface corresponding to chunk
	}
	update {
		chunk.block.statements.filter[it instanceof Referenceable].forEach [
			createOrFindPCMSignature(it as Referenceable)
		]
	}
}

routine createSeffFromChunk(lua::Referenceable functionDeclaration, lua::Chunk chunk) {
	match {
		val opInterface = retrieve pcm::OperationInterface corresponding to chunk
		require absence of pcm::ResourceDemandingSEFF corresponding to functionDeclaration
	}
	update {
		if (!functionDeclaration.local) {
			createSEFF(functionDeclaration, chunk)
		}
	}
}

//routine createSeffFromImplementingInterfaces(lua::Referenceable classMethod, java::Class javaClass) {
//	match {
//		require absence of pcm::ResourceDemandingSEFF corresponding to classMethod
//	}
//	update {
//		if (classMethod.modifiers.filter(Abstract).size !== 0) {
//			return;
//		}
//		val implementingInterfaces = findImplementingInterfacesFromTypeRefs(javaClass.implements)
//		for (implementingInterface : implementingInterfaces) {
//			createSeffFromImplementingInterface(classMethod, javaClass, implementingInterface)
//		}
//	}
//}
//
//routine createSeffFromImplementingInterface(lua::Referenceable classMethod, java::Class javaClass, java::Interface javaInterface) {
//	match {
//		val operationInterface = retrieve pcm::OperationInterface corresponding to javaInterface
//	}
//	update {
//		val methods = javaInterface.methods.filter[hasSameSignature(classMethod)]
//		for (method : methods) {
//			createSEFF(method, javaClass, classMethod)
//		}
//	}
//}
//routine createSEFF(lua::Referenceable javaMethod, java::Class javaClass, lua::Referenceable classMethod) {
routine createSEFF(lua::Referenceable functionDeclaration, lua::Chunk chunk) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
		// TODO check if this correspondence is added when components are added
		val basicComponent = retrieve pcm::BasicComponent corresponding to chunk
	}
	create {
		val rdseff = new pcm::ResourceDemandingSEFF
	}
	update {
		rdseff.describedService__SEFF = operationSignature
		rdseff.basicComponent_ServiceEffectSpecification = basicComponent
		addCorrespondenceBetween(functionDeclaration, rdseff)
		basicComponent.serviceEffectSpecifications__BasicComponent += rdseff
	}
}

routine createParameter(lua::Referenceable functionParameter, lua::Referenceable functionDeclaration) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
	}
	create {
		val pcmParameter = new pcm::Parameter
	}
	update {
//		checkCollectionDataTypeCreation(functionParameter.typeReference)
		pcmParameter.operationSignature__Parameter = operationSignature
//		pcmParameter.dataType__Parameter = TypeReferenceCorrespondenceHelper.
//			getDataTypeFromTypeReference(javaParameter.typeReference, correspondenceModel, userInteractor,
//				operationSignature.interface__OperationSignature.repository__Interface)
//		pcmParameter.name = javaParameter.name
		pcmParameter.name = functionParameter.name

		addCorrespondenceBetween(functionParameter, pcmParameter)
		operationSignature.parameters__OperationSignature += pcmParameter
//		checkInnerDeclarationsCreation(pcmParameter.dataType__Parameter, javaParameter.typeReference)
	}
}

routine changeParameterName(String newName, lua::Referenceable functionParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to functionParameter
	}
	update {
		pcmParameter.name = newName
	}
}

//routine updateReturnType(java::Method javaMethod, java::TypeReference typeReference) {
//	match {
//		val operationSignature = retrieve pcm::OperationSignature corresponding to javaMethod
//	}
//	update {
//		val repository = operationSignature.interface__OperationSignature.repository__Interface
//		operationSignature.returnType__OperationSignature = getCorrespondingPCMDataTypeForTypeReference(typeReference,
//			correspondenceModel, userInteractor, repository, javaMethod.typeReference.arrayDimension)
//	}
//}

routine checkRemovalOfOperationSignature(lua::Referenceable functionDeclaration) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
	}
	update {
		for (param : functionDeclaration.function.arguments) {
//			if (param instanceof OrdinaryParameter) {
				deleteParameter(param)
//			}
		}
		// Should the corresponding SEFFs still exist?
		// Should the references to the removed OperationSignature in all rdseff.describedService__SEFF also be removed?
		removeObject(operationSignature)
	}
}

routine checkRemovalOfSEFF(lua::Referenceable functionDeclaration) {
	match {
		val seff = retrieve pcm::ResourceDemandingSEFF corresponding to functionDeclaration
	}
	update {
		removeObject(seff)
	}
}

routine deleteParameter(lua::Referenceable functionParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to functionParameter
	}
	update {
		removeCorrespondenceBetween(functionParameter, pcmParameter)
		removeObject(pcmParameter)
	}
}
