import org.eclipse.xtext.EcoreUtil2
import org.xtext.lua.lua.Component
import org.xtext.lua.lua.NamedChunk

import static extension edu.kit.ipd.sdq.commons.util.org.palladiosimulator.pcm.repository.ParameterUtil.*

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm

reactions: commonSignature
in reaction to changes in lua
execute actions in pcm

routine createOrFindPCMSignature(lua::Statement_Global_Function_Declaration functionDeclaration) {
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to EcoreUtil2.getContainerOfType(
			functionDeclaration, NamedChunk)
		require absence of pcm::OperationSignature corresponding to functionDeclaration
	}
	create {
		val operationSignature = new pcm::OperationSignature
	}
	update {
		operationSignature.entityName = functionDeclaration.name
		operationSignature.interface__OperationSignature = pcmInterface
		pcmInterface.signatures__OperationInterface += operationSignature

		addCorrespondenceBetween(functionDeclaration, operationSignature)
	}
}

//routine checkMembersForOperations(lua::Chunk chunk) {
//	match {
//		retrieve pcm::OperationInterface corresponding to chunk
//	}
//	update {
//		chunk.block.statements.filter[it instanceof Statement_Global_Function_Declaration].forEach [
//			createOrFindPCMSignature(it as Statement_Global_Function_Declaration)
//		]
//	}
//}

routine assertSeffForFunction(lua::Statement_Global_Function_Declaration functionDeclaration) {
	match {
		require absence of pcm::ResourceDemandingSEFF corresponding to functionDeclaration
	}
	update {
		createSEFF(functionDeclaration)
	}
}

//routine createSeffFromImplementingInterfaces(lua::Referenceable classMethod, java::Class javaClass) {
//	match {
//		require absence of pcm::ResourceDemandingSEFF corresponding to classMethod
//	}
//	update {
//		if (classMethod.modifiers.filter(Abstract).size !== 0) {
//			return;
//		}
//		val implementingInterfaces = findImplementingInterfacesFromTypeRefs(javaClass.implements)
//		for (implementingInterface : implementingInterfaces) {
//			createSeffFromImplementingInterface(classMethod, javaClass, implementingInterface)
//		}
//	}
//}
//
//routine createSeffFromImplementingInterface(lua::Referenceable classMethod, java::Class javaClass, java::Interface javaInterface) {
//	match {
//		val operationInterface = retrieve pcm::OperationInterface corresponding to javaInterface
//	}
//	update {
//		val methods = javaInterface.methods.filter[hasSameSignature(classMethod)]
//		for (method : methods) {
//			createSEFF(method, javaClass, classMethod)
//		}
//	}
//}

routine createSEFF(lua::Statement_Global_Function_Declaration functionDeclaration) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
		val basicComponent = retrieve pcm::BasicComponent corresponding to EcoreUtil2.getContainerOfType(functionDeclaration, Component)
	}
	create {
		val rdseff = new pcm::ResourceDemandingSEFF
	}
	update {
		rdseff.describedService__SEFF = operationSignature
		rdseff.basicComponent_ServiceEffectSpecification = basicComponent
		addCorrespondenceBetween(functionDeclaration, rdseff)
		basicComponent.serviceEffectSpecifications__BasicComponent += rdseff
	}
}

routine createParameter(lua::Referenceable functionParameter, lua::Statement_Global_Function_Declaration functionDeclaration) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
	}
	create {
		val pcmParameter = new pcm::Parameter
	}
	update {
//		checkCollectionDataTypeCreation(functionParameter.typeReference)
		pcmParameter.operationSignature__Parameter = operationSignature
//		pcmParameter.dataType__Parameter = TypeReferenceCorrespondenceHelper.
//			getDataTypeFromTypeReference(javaParameter.typeReference, correspondenceModel, userInteractor,
//				operationSignature.interface__OperationSignature.repository__Interface)
//		pcmParameter.name = javaParameter.name
		pcmParameter.name = functionParameter.name

		addCorrespondenceBetween(functionParameter, pcmParameter)
		operationSignature.parameters__OperationSignature += pcmParameter
//		checkInnerDeclarationsCreation(pcmParameter.dataType__Parameter, javaParameter.typeReference)
	}
}

routine changeParameterName(String newName, lua::Referenceable functionParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to functionParameter
	}
	update {
		pcmParameter.name = newName
	}
}

//routine updateReturnType(java::Method javaMethod, java::TypeReference typeReference) {
//	match {
//		val operationSignature = retrieve pcm::OperationSignature corresponding to javaMethod
//	}
//	update {
//		val repository = operationSignature.interface__OperationSignature.repository__Interface
//		operationSignature.returnType__OperationSignature = getCorrespondingPCMDataTypeForTypeReference(typeReference,
//			correspondenceModel, userInteractor, repository, javaMethod.typeReference.arrayDimension)
//	}
//}


routine checkRemovalOfOperationSignature(lua::Statement_Global_Function_Declaration functionDeclaration) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
	}
	update {
		for (param : functionDeclaration.function.arguments) {
//			if (param instanceof OrdinaryParameter) {
			deleteParameter(param)
//			}
		}
		// Should the corresponding SEFFs still exist?
		// Should the references to the removed OperationSignature in all rdseff.describedService__SEFF also be removed?
		removeObject(operationSignature)
	}
}

routine checkRemovalOfSEFF(lua::Referenceable functionDeclaration) {
	match {
		val seff = retrieve pcm::ResourceDemandingSEFF corresponding to functionDeclaration
	}
	update {
		removeObject(seff)
	}
}

routine deleteParameter(lua::Referenceable functionParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to functionParameter
	}
	update {
		removeCorrespondenceBetween(functionParameter, pcmParameter)
		removeObject(pcmParameter)
	}
}
